Track waste:
SELECT product_id,
       SUM(CASE WHEN event_type = 'discarded' THEN quantity ELSE 0 END) AS wasted_quantity,
       SUM(quantity) AS total_quantity,
       (SUM(CASE WHEN event_type = 'discarded' THEN quantity ELSE 0 END) / SUM(quantity)) * 100 AS waste_percentage
FROM consumption_log
WHERE user_id = 101
GROUP BY product_id;


show top 5?
add estimated wasted money
Create bar charts or pie charts that display the proportion of wasted items.
Provide drill-down details showing which products have high waste percentages.

# weekly report - products that will expire this week
#                 products that are low on stock
#                 how much wasted this week


CREATE TABLE user_product_history (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    product_id INT,
    purchase_date DATE,
    quantity_purchased INT,   -- How much the user bought
    quantity_consumed INT,    -- How much was used before expiration
    quantity_thrown_out INT,  -- How much was wasted
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);

Extract Data from Your Database
import pandas as pd
import mysql.connector

# Connect to the MySQL database
conn = mysql.connector.connect(
    host='localhost',
    user='your_username',
    password='your_password',
    database='your_database'
)

# Query the data from your table
query = "SELECT * FROM user_product_history"
df = pd.read_sql(query, conn)
conn.close()

# Ensure the purchase_date column is a datetime type
df['purchase_date'] = pd.to_datetime(df['purchase_date'])

Filter and Prepare Data for a Specific Userâ€“Product Combination
# Define the specific user and product to forecast
user_id = 101
product_id = 3

# Filter the DataFrame for this combination
df_filtered = df[(df['user_id'] == user_id) & (df['product_id'] == product_id)].copy()
df_filtered.sort_values('purchase_date', inplace=True)

# Prepare the DataFrame for forecasting quantity purchased
df_purchase = df_filtered[['purchase_date', 'quantity_purchased']].rename(
    columns={'purchase_date': 'ds', 'quantity_purchased': 'y'}
)

# Prepare the DataFrame for forecasting quantity thrown out
df_thrown = df_filtered[['purchase_date', 'quantity_thrown_out']].rename(
    columns={'purchase_date': 'ds', 'quantity_thrown_out': 'y'}
)

Build Prophet Models
from prophet import Prophet

# Initialize and fit the Prophet model for purchases
model_purchase = Prophet()
model_purchase.fit(df_purchase)

# Create a DataFrame to hold future dates
# We assume you want to forecast 4 weeks into the future.
# Since your data is aggregated weekly with dates at the start of the week, we set freq='W-MON'
future_purchase = model_purchase.make_future_dataframe(periods=4, freq='W-MON')

# Generate the forecast
forecast_purchase = model_purchase.predict(future_purchase)

# The forecasted purchase quantities are in forecast_purchase['yhat']
print(forecast_purchase[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail())

# Initialize and fit the Prophet model for thrown out quantities
model_thrown = Prophet()
model_thrown.fit(df_thrown)

# Create a future DataFrame (same parameters as above)
future_thrown = model_thrown.make_future_dataframe(periods=4, freq='W-MON')

# Generate the forecast
forecast_thrown = model_thrown.predict(future_thrown)

# The forecasted thrown out quantities are in forecast_thrown['yhat']
print(forecast_thrown[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail())


Combine the Forecasts
# Combine the forecasts based on the date (ds)
forecast_combined = pd.DataFrame({
    'ds': forecast_purchase['ds'],
    'quantity_estimated': forecast_purchase['yhat'],
    'amount_thrown_out_estimated': forecast_thrown['yhat']
})

# Add identifiers for the user and product
forecast_combined['user_id'] = user_id
forecast_combined['product_id'] = product_id

# Display the combined forecast for the future dates only
print(forecast_combined.tail(4))


Evaluation
Incorporating External Regressors


python -m backend.DS.randomised_history_insert
python -m backend.DS.predict_shopping_waste